ShaderType = Fragment;

Input fsIn{
    float4 position: SRV_POSITION;
    float3 normal: Normal;
    float2 texCoords: TexCoords;
};

Output fsOut{
    float4 color: SRV_TARGET0;
};

float3 palette(float d){
    return mix(float3(0.2, 0.7, 0.9), float3(1.0, 0.0f, 1.0f), d);
}

float2 rotate(float2 p, float angle){
    float s = sin(angle);
    float c = cos(angle);
    float2x2 rot = float2x2(c, s, -s, c);
    return p * rot;
}

float map(float3 p, float time){
    for (int i = 0; i < 8; i++){
        float t = time * 0.2;
        p.xz = rotate(p.xz, t);
        p.xy = rotate(p.xy, t * 1.89);
        p.xz = abs(p.xz);
        p.xz = p.xz - 0.5;
    }
    return dot(sign(p), p) / 0.5f;
}

float4 rayMarch(float3 ro, float3 rd, float time){
    float t = 0.0f;
    float d = 0.0f;
    float3 col = float3(0.0f, 0.0f, 0.0f);
    for (float i = 0.0f; i < 64.0f; i++){
        float3 p = ro + rd * t;
        d = map(p, time) * 0.5f;

        if (d < 0.02f){
            break;
        }
        if (d > 100.0f){
            break;
        }
        col = col + palette(length(p) * 0.1f) / (400.0f * d);
        t = t + d;
    }
    return float4(col, 1.0f / (d * 100.0f));
}

float4 calculateColor(float2 uv, float time){
    float3 ro = float3(0.0f, 0.0f, -50.0f);
    ro.xz = rotate(ro.xz, time);
    float3 cf = normalize(1.0f - ro);
    float3 cs = normalize(cross(cf, float3(0.0f, 1.0f, 0.0f)));
    float3 cu = normalize(cross(cf, cs));

    float3 uuv = ro + cf * 3.0f + uv.x * cs + uv.y * cu;

    float3 rd = normalize(uuv - ro);
    return rayMarch(ro, rd, time);
}

void main(){
    float time = 5.0f;
    fsOut.color = calculateColor(fsIn.texCoords, time);
}